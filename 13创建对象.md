#### ES6开始支持类和继承 但是都仅仅是封装了ES5.1构造函数加原型继承的语法糖

1. ### 工厂模式(一种设计模式，用于抽象创建特定对象的过程)

- 例 按照一种特定接口创建对象的方式

  ```javascript
  function creatPerson(name,age,sex){
      let o =new Object();
      o.name=name;
      o.age=age;
      o.sex=sex;
      return o;
  }
  let person1 =creatPerson('lukas',21,'boy');
  let person2 =creatPerson('joney',20,'girl');
  ```

  上例使用构造函数模式

  - 构造函数首字母必须大写
  - 创建实例需要用new操作符
  - 实例化时 不传入参数构造函数后面的括号可加可不加

  ```javascript
  function Creatperson(name,age,sex){
      this.name=name;
      this.age=age;
      this.sex=sex;
      this.Sayhi=function(){
          console.log(this.name)
      }
  }
  let person3= new Creatperson('ukkkk',28,'boy')
  ```

  1. 构造函数也是函数

     对构造函数普通调用在没有明确设置this值的情况下，this始终指向Global对象

  2. 构造函数的问题

     定义的方法会在每个实例上都创建一遍，上例中Sayhi函数 在定义时 都会初始化一个功能相同的对象 可以将函数的定义转到构造函数的外部来解决这个问题

     ```javascript
     function Creatperson(name,age,sex){
         this.name=name;
         this.age=age;
         this.sex=sex;
         this.sayHi=sayHi;
     }
     function sayHi(){
         console.log(this.name);
     }
     ```

2. ### 原型模式

   - 每个函数都会创建一个prototype属性，这个属性是一个对象 是调用构造函数创建的对象的原型 在它上面定义的属性和方法可以被对象实例共享

     ```javascript
     let Person = function(){
         Person.prototype.name='lukas';
         Person.prototype.age=22;
         Person.prototype.sayHi=function(){
             console.log(this.name);
             
         }
     }
     let person1 = new Person();
     let person2 = new Person();
     ```

3. ### 对象迭代

   - Object.values()返回内容的数组
   - Object.entries()返回键/值对的数组